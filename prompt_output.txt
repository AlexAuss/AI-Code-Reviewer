Directions:

Act as a code reviewer. Using the results as examples below, write a review comment for the User Query and limit the response to 10 sentences. If you determine it needs to be refined, provide the refined version of the code after the review comment. The review comment section must start with a header, "Review Comment:", on its own line, as well as the "Refined Code:" section. Do not include additional text before or after these sections.



Result 1
Original Patch:
@@ -48,23 +59,29 @@ bool TransformationAddGlobalVariable::IsApplicable(
   if (!pointer_type) {
     return false;
   }
-  // ... with Private storage class.
-  if (pointer_type->storage_class() != SpvStorageClassPrivate) {
+  // ... with the right storage class.
+  if (pointer_type->storage_class() != storage_class) {
     return false;
   }
-  // The initializer id must be the id of a constant.  Check this with the
-  // constant manager.
-  auto constant_id = ir_context->get_constant_mgr()->GetConstantsFromIds(
-      {message_.initializer_id()});
-  if (constant_id.empty()) {
-    return false;
-  }
-  assert(constant_id.size() == 1 &&
-         "We asked for the constant associated with a single id; we should "
-         "get a single constant.");
-  // The type of the constant must match the pointee type of the pointer.
-  if (pointer_type->pointee_type() != constant_id[0]->type()) {
-    return false;
+  if (message_.initializer_id()) {
+    // An initializer is not allowed if the storage class is Workgroup.
+    if (storage_class == SpvStorageClassWorkgroup) {
+      return false;
+    }
Review Comment:
Maybe assert false
Refined Patch:
@@ -66,6 +66,9 @@ bool TransformationAddGlobalVariable::IsApplicable(
   if (message_.initializer_id()) {
     // An initializer is not allowed if the storage class is Workgroup.
     if (storage_class == SpvStorageClassWorkgroup) {
+      assert(false &&
+             "By construction this transformation should not have an "
+             "initializer when Workgroup storage class is used.");
       return false;
     }
     // The initializer id must be the id of a constant.  Check this with the


Result 2
Original Patch:
@@ -13,21 +13,17 @@
 
 public class OnThisDayActivity extends SingleFragmentActivity<OnThisDayFragment> {
     public static final String AGE = "age";
+    public static final String YEAR = "year";
     public static final String WIKISITE = "wikisite";
 
-    public static Intent newIntent(@NonNull Context context, int age, WikiSite wikiSite, InvokeSource invokeSource) {
+    public static Intent newIntent(@NonNull Context context, int age, WikiSite wikiSite, InvokeSource invokeSource, int year) {
Review Comment:
Would it be better if add annotations to the parameters?
Refined Patch:
@@ -16,7 +16,7 @@ public class OnThisDayActivity extends SingleFragmentActivity<OnThisDayFragment>
     public static final String YEAR = "year";
     public static final String WIKISITE = "wikisite";
 
-    public static Intent newIntent(@NonNull Context context, int age, WikiSite wikiSite, InvokeSource invokeSource, int year) {
+    public static Intent newIntent(@NonNull Context context, int age, @NonNull WikiSite wikiSite, @NonNull InvokeSource invokeSource, int year) {
         return new Intent(context, OnThisDayActivity.class)
                 .putExtra(AGE, age)
                 .putExtra(WIKISITE, wikiSite)


Result 3
Original Patch:
@@ -80,7 +80,7 @@ def target_url
     return external_url if external_url
     return "#{Discourse::base_uri}#{post.url}" if post
     return topic.relative_url if topic
-    return "#{category.url}/#{category.id}" if category
+    return "#{category.url}" if category
Review Comment:
```suggestion return category.url if category ```
Refined Patch:
@@ -80,7 +80,7 @@ class Permalink < ActiveRecord::Base
     return external_url if external_url
     return "#{Discourse::base_uri}#{post.url}" if post
     return topic.relative_url if topic
-    return "#{category.url}" if category
+    return category.url if category
     return tag.full_url if tag
     nil
   end


Result 4
Original Patch:
@@ -250,13 +250,22 @@ func (c *twoPhaseCommitter) prewriteSingleBatch(bo *Backoffer, batch batchKeys)
 	for i, k := range batch.keys {
 		mutations[i] = c.mutations[string(k)]
 	}
+
+	skipCheck := false
+	optSkipCheck := c.txn.us.GetOption(kv.SkipCheckForWrite)
+	if optSkipCheck != nil {
Review Comment:
We don't need to check not nil before try to assert to bool.
Refined Patch:
@@ -253,10 +253,8 @@ func (c *twoPhaseCommitter) prewriteSingleBatch(bo *Backoffer, batch batchKeys)
 
 	skipCheck := false
 	optSkipCheck := c.txn.us.GetOption(kv.SkipCheckForWrite)
-	if optSkipCheck != nil {
-		if skip, ok := optSkipCheck.(bool); ok && skip {
-			skipCheck = true
-		}
+	if skip, ok := optSkipCheck.(bool); ok && skip {
+		skipCheck = true
 	}
 	req := &pb.Request{
 		Type: pb.MessageType_CmdPrewrite,


Result 5
Original Patch:
@@ -1659,6 +1659,80 @@ def process_asg(self, client, asg):
             raise
 
 
+@ASG.action_registry.register('update')
+class Update(Action):
+    """Action to update ASG configuration settings
+
+    :example:
+
+    .. code-block:: yaml
+
+            policies:
+              - name: set-asg-instance-lifetime
+                resource: asg
+                filters:
+                  - MaxInstanceLifetime: empty
+                actions:
+                  - type: update
+                    max-instance-lifetime: 604800  # (7 days)
+
+              - name: set-asg-by-policy
+                resource: asg
+                actions:
+                  - type: update
+                    default-cooldown: 600
+                    max-instance-lifetime: 0      # (clear it)
+                    new-instances-protected-from-scale-in: true
+                    capacity-rebalance: true
+    """
+
+    schema = type_schema(
+        'update',
+        **{
+            'default-cooldown': {'type': 'integer', 'minimum': 0},
+            'max-instance-lifetime': {
+                "anyOf": [
+                    {'enum': [0]},
+                    {'type': 'integer', 'minimum': 86400}
+                ]
+            },
+            'new-instances-protected-from-scale-in': {'type': 'boolean'},
+            'capacity-rebalance': {'type': 'boolean'},
+        }
+    )
+    permissions = ("autoscaling:UpdateAutoScalingGroup",)
+    settings_map = {
+        "default-cooldown": "DefaultCooldown",
+        "max-instance-lifetime": "MaxInstanceLifetime",
+        "new-instances-protected-from-scale-in": "NewInstancesProtectedFromScaleIn",
+        "capacity-rebalance": "CapacityRebalance"
+    }
+
+    def process(self, asgs):
+        client = local_session(self.manager.session_factory).client('autoscaling')
+
+        settings = {}
+        for k, v in self.settings_map.items():
+            if k in self.data:
+                settings[v] = self.data.get(k)
+
+        with self.executor_factory(max_workers=2) as w:
+            futures = {}
+            for a in asgs:
+                futures[w.submit(self.process_asg, client, a, settings)] = a
+            for f in as_completed(futures):
+                if f.exception():
Review Comment:
per current error handling best practices, its fine to continue for other resources in this action, but we want to stop policy exec by raising at the end of processing. ```python # pseudo error = None if f.exception() error = f.exception() if error: raise error ```
Refined Patch:
@@ -1718,6 +1718,7 @@ class Update(Action):
 
         with self.executor_factory(max_workers=2) as w:
             futures = {}
+            error = None
             for a in asgs:
                 futures[w.submit(self.process_asg, client, a, settings)] = a
             for f in as_completed(futures):


User Query:

print(Hello World